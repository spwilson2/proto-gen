use std::io::BufWriter;

use serde::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};

pub mod codegen_csharp;
pub mod codegen_rust;
pub mod intern;
pub mod parse_tree;
pub mod parser;
pub mod serializable_tree;

fn main() {
    println!("Hello, world!");
    let mut stat = [0u8; 1000];
    let mut buf = stat.as_mut_slice();
    //let BufWriter::new();
    //let writer: &mut dyn std::io::Write = &mut buf;
    let val = Ex { val: 1 };
    //serde_json::from_slice(buf)
    //serde_json::to_writer(buf, &val).or(Err(()));
    //serde_json::to_string(&val)
    //    .or(Err(()))
    //    .unwrap()
    //    .as_bytes()
    //    .len()
}
#[derive(Serialize)]
struct Ex {
    val: u64,
}
//use parking_lot::Mutex;
//use serde::Deserialize;
//use std::{
//    collections::VecDeque,
//    mem::size_of,
//    net::UdpSocket,
//    sync::Arc,
//    thread::{self, JoinHandle},
//    time::Duration,
//};
//
//// Autogenerated
//type MessageId = str;
//
//pub trait ProtoSerial
//where
//    Self: Sized,
//{
//    fn serialize_into(&self, buf: &mut [u8]) -> Result<(), usize>;
//    //fn serialized_size(&self);
//    fn try_deserialize(buf: &[u8]) -> Option<Self>;
//    fn deserialize(buf: &[u8]) -> Self {
//        Self::try_deserialize(buf).unwrap()
//    }
//}
//#[derive(Debug, Clone, Serialize, Deserialize)]
//pub struct Input {
//    key_code: KeyCode, // 0
//}
//
//impl ProtoSerial for Input {
//    fn serialize_into(&self, buf: &mut [u8]) -> Result<(), ()> {
//        serde_json::to_writer(buf, self).or(Err(()))
//    }
//    // fn serialized_size(&self) {
//    //     serde_json::to_string(&val)
//    //         .or(Err(()))
//    //         .unwrap()
//    //         .as_bytes()
//    //         .len()
//    //         todo!()
//    // }
//    fn try_deserialize(buf: &[u8]) -> Option<Self> {
//        serde_json::from_slice(buf).ok()
//    }
//}
//#[derive(Debug, Clone, Serialize, Deserialize)]
//pub struct Empty {}
//
//impl ProtoSerial for Empty {
//    fn serialize_into(&self, buf: &mut [u8]) -> Result<(), ()> {
//        serde_json::to_writer(buf, self).or(Err(()))
//    }
//    // fn serialized_size(&self) {
//    //     serde_json::to_string(&val)
//    //         .or(Err(()))
//    //         .unwrap()
//    //         .as_bytes()
//    //         .len()
//    //         todo!()
//    // }
//    fn try_deserialize(buf: &[u8]) -> Option<Self> {
//        serde_json::from_slice(buf).ok()
//    }
//}
#[derive(Serialize, Deserialize)]
enum KeyCode {
    Spacebar,
}
//enum BackendMessage {
//    InputEventArg(Input),
//    InputEventRet(Empty),
//}
