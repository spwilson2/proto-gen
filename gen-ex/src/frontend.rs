use bevy::prelude::*;
use bincode::Options;
use parking_lot::Mutex;
use serde::{Deserialize, Serialize};
use std::{
    collections::VecDeque,
    mem::size_of,
    net::UdpSocket,
    sync::{
        mpsc::{sync_channel, Receiver},
        Arc,
    },
    thread::{self, JoinHandle},
    time::Duration,
};

const MAX_MSG_SIZE: usize = 4096;
const MAX_PENDING_MSG: usize = 1000;

#[derive(Resource, Debug)]
struct FrontendService {
    thread: JoinHandle<()>,
    pub queue: std::sync::mpsc::SyncSender<FrontendCommand>,
}

type Id = u64;

// Autogenerated
#[repr(C)]
struct MessageWireHeader {
    _size: u64,
    // Bincode deserialize of string is a network byte order
    id: [u8],
}
// Autogenerated
type MessageId = str;
// Autogenerated
const MoveCommandId: &'static MessageId = "Move";
// Autogenerated
#[derive(Serialize, Default, Debug)]
struct Move {
    id: Id,
    x: f32,
    y: f32,
}
// Autogenerated
#[derive(Serialize, Debug)]
#[repr(transparent)]
struct MoveCommand(Move);
#[derive(Debug)]
enum FrontendCommand {
    MoveCommand(Move),
}
// Autogenerated
trait ToFrontendCommand {
    fn to_frontend_command(self) -> FrontendCommand;
}
// Autogenerated
impl ToFrontendCommand for MoveCommand {
    fn to_frontend_command(self) -> FrontendCommand {
        FrontendCommand::MoveCommand(self.0)
    }
}

// User public interface
// Autogenerated
impl FrontendService {
    // Autogenerated function
    pub fn move_command(&self, arg: Move) {
        self.queue
            .try_send(FrontendCommand::MoveCommand(arg))
            .expect("FrontendService queue full!");
    }

    // Autogenerated serializing code
    pub fn serialize_message(buf: &mut [u8], cmd: FrontendCommand) -> Option<usize> {
        let net_serializer = bincode::DefaultOptions::new()
            .with_big_endian() // Network byte order
            .with_fixint_encoding()
            .allow_trailing_bytes();
        match cmd {
            FrontendCommand::MoveCommand(arg) => {
                let header = MoveCommandId;
                let header_size = net_serializer.serialized_size(&header).unwrap() as usize;
                let body_size = net_serializer.serialized_size(&arg).unwrap() as usize;
                let amt = header_size + body_size;
                if buf.len() < amt {
                    return None;
                }
                net_serializer
                    .serialize_into(&mut buf[..header_size], &header)
                    .unwrap();
                net_serializer
                    .serialize_into(&mut buf[header_size..], &arg)
                    .unwrap();
                Some(amt)
            }
        }
    }
}

impl FrontendService {
    fn new(socket: String, target: String) -> Self {
        let (sender, receiver) = sync_channel(MAX_PENDING_MSG);
        Self {
            thread: std::thread::spawn(move || Self::worker_loop((socket, target), receiver)),
            queue: sender,
        }
    }
    // Runs in a separate thread
    fn worker_loop(sock_params: (String, String), mut queue: Receiver<FrontendCommand>) {
        // Note: Needs to maintain connection and handle shutdown.
        loop {
            // TODO: Handle some eventual failure?
            let _ = Self::worker_inner(&sock_params, &mut queue);
        }
    }
    fn worker_inner(
        sock_params: &(String, String),
        queue: &mut Receiver<FrontendCommand>,
    ) -> std::io::Result<()> {
        let sock = UdpSocket::bind(sock_params.0.clone())?;
        let target = &sock_params.1.clone();
        let buf = &mut [0; MAX_MSG_SIZE];

        loop {
            let cmd = queue.recv().unwrap();
            // TODO/Optimization: Need to merge commands if possible, easy algo
            // is just to merge while there's still more in pipe.
            // NOTE: While we're not merging messages, this will never fail.
            // Will need to be fixed once optimized.
            let amt = FrontendService::serialize_message(buf, cmd).unwrap();

            // TODO: Error handling. need to at least detect when our own socket
            // is broken so we can recreate it.
            let _ = sock.send_to(&buf[..amt], target);
        }
    }
}

pub fn main() {
    let mut app = App::new();
    app.insert_resource(bevy::app::ScheduleRunnerSettings::run_loop(
        Duration::from_secs_f64(1.0 / 60.0),
    ))
    .add_plugins(MinimalPlugins)
    .insert_resource(FrontendService::new(
        "127.0.0.1:11004".into(),
        "127.0.0.1:11005".into(),
    ))
    .add_system(sys_write_cmd);
    app.run();
}

fn sys_write_cmd(frontend: Res<FrontendService>, mut cnt: Local<u32>) {
    if *cnt > 1 {
        return;
    }
    *cnt += 1;
    frontend.move_command(Move {
        id: 1,
        x: 100.0,
        y: 200.0,
    });
}

#[test]
fn test_main() {
    // Create the "frontend server"
    //    let sock = UdpSocket::bind("127.0.0.1:11005").unwrap();
    //    sock.set_read_timeout(Some(Duration::from_secs_f32(1.0)))
    //        .unwrap();
    //
    let handle = std::thread::spawn(|| main());
    let mut buf = &mut [0u8; 256];
    thread::sleep(Duration::from_secs_f32(1.0));
    //sock.recv(buf).unwrap();
    //handle.join();
}
